---
title: jvm学习笔记(1)——jvm回收条件
date: 2018-04-24 22:56:45
categories: jvm
tags: jvm
---

# 回收区域

- GC区域：**堆、方法区**
- 不GC的区域：程序计数器、虚拟机栈、本地方法栈

## 堆回收

- 引用计数法：有引用就会记1
  - 会有循环引用的问题
  - 主流jvm不使用这种方式
- 可达性分析法：判断到GC-root
  - GC root 对象
    - jvm中栈帧中引用的对象
    - 方法区中静态属性(static)、常量(final)引用的对象
- 引用分类
  - 强引用：`Object ojb = new Object()`， 只要有强引用，不会被GC
  - 软引用：可以用`SoftReference`来实现。内存溢出时，进行二次回收。第二次还没有足够内存，抛内存溢出异常。
  - 弱引用：可以用`WeakReference`来实现。只能生存到下一次GC之前。无论内存是否够，都会被GC.
  - 虚引用：可以用`PhantomReference`来实现。GC时会收到一个系统通知。
  - 强引用 > 软引用 > 弱引用 > 虚引用


- 什么时候回收
  - 如果对象不可达，判断是否需要执行`finalize()`方法
    - 不需要执行`finalize()` 的情况：
      - 没有`overwrite` `finalize()`方法
      - 虚拟机已经执行过一次`finalize()`
  - 如果需要执行`finalize()`方法， 放入`F-Queue`中，在`finalize()`执行完后还是满足回收的条件，宣判“死刑"被回收。

## 方法区（永久代）回收

方法区回收的能够回收的空间有限。

- 回收：
  - 废弃常量：无引用，和heap类似。
  - 无用的类必须满足的条件
    - java堆中不存在该类的任何对象
    - 加载该类的`classLoader`已经被回收
    - 这个类对应的`java.lang.class` 对象没有在任何地方被引用。
- class类扩展
  - 因为java是运行时类型识别，`class` 类是保存这些识别信息的类，即：保存了每个对象的类型信息。可以通过这些信息反射创建一个实例。判断一下有没有引用就理所当然了，因为如果有引用，那么就可能有对这个对象类型信息的依赖，就不可以被回收。



# 参考资料

* [深入探究JVM | 探秘 Metaspace](https://www.sczyh30.com/posts/Java/jvm-metaspace/)